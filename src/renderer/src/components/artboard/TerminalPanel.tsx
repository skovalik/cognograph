/**
 * TerminalPanel.tsx — Renderer-side xterm.js terminal component for artboard mode.
 *
 * Mounts an xterm.js Terminal instance, connects to the main-process PTY via the
 * preload IPC bridge (window.api.terminal), and handles:
 *   - Scrollback replay on mount
 *   - Keystroke forwarding to PTY
 *   - PTY output rendering
 *   - Debounced resize (150ms) via @xterm/addon-fit
 *   - PTY exit display
 *   - Ctrl+` focus escape to return to canvas
 *
 * Session lifecycle: On unmount the component detaches listeners but does NOT kill
 * the PTY session, so the terminal persists across artboard toggles.
 */

import { useEffect, useRef, useCallback, memo } from 'react'
import { Terminal } from '@xterm/xterm'
import { FitAddon } from '@xterm/addon-fit'
import '@xterm/xterm/css/xterm.css'

// ---------------------------------------------------------------------------
// Props
// ---------------------------------------------------------------------------

export interface TerminalPanelProps {
  /** Canvas node ID that owns this terminal session. */
  nodeId: string
  /** Unique session identifier (generated by caller). */
  sessionId: string
  /** Optional accent color override (CSS color string). Applied as cursor color. */
  accentColor?: string
  /** Additional CSS class names for the container div. */
  className?: string
}

// ---------------------------------------------------------------------------
// Theme
// ---------------------------------------------------------------------------

const terminalTheme = {
  background: '#1a1a2e',
  foreground: '#e0e0e0',
  cursor: '#7c3aed',
  cursorAccent: '#1a1a2e',
  selectionBackground: 'rgba(124, 58, 237, 0.3)',
  black: '#1a1a2e',
  red: '#ef4444',
  green: '#22c55e',
  yellow: '#eab308',
  blue: '#3b82f6',
  magenta: '#a855f7',
  cyan: '#06b6d4',
  white: '#e0e0e0',
  brightBlack: '#4a4a5e',
  brightRed: '#f87171',
  brightGreen: '#4ade80',
  brightYellow: '#facc15',
  brightBlue: '#60a5fa',
  brightMagenta: '#c084fc',
  brightCyan: '#22d3ee',
  brightWhite: '#ffffff',
}

// ---------------------------------------------------------------------------
// Constants
// ---------------------------------------------------------------------------

const RESIZE_DEBOUNCE_MS = 150

// ---------------------------------------------------------------------------
// Component
// ---------------------------------------------------------------------------

/**
 * TerminalPanel renders an xterm.js terminal connected to a main-process PTY.
 *
 * Mount sequence:
 * 1. Create Terminal + FitAddon instances
 * 2. Open terminal into the container div
 * 3. Spawn PTY via IPC (or reconnect to existing session)
 * 4. Replay scrollback buffer
 * 5. Attach fit addon and perform initial fit
 * 6. Wire up data/exit/resize listeners
 *
 * Unmount: Dispose terminal + addon, remove IPC listeners. PTY stays alive.
 */
function TerminalPanelInner({
  nodeId,
  sessionId,
  accentColor,
  className,
}: TerminalPanelProps): JSX.Element {
  const containerRef = useRef<HTMLDivElement>(null)
  const terminalRef = useRef<Terminal | null>(null)
  const fitAddonRef = useRef<FitAddon | null>(null)
  const resizeTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  const mountedRef = useRef(true)

  // -------------------------------------------------------------------------
  // Debounced resize handler
  // -------------------------------------------------------------------------
  const handleResize = useCallback(() => {
    if (resizeTimerRef.current !== null) {
      clearTimeout(resizeTimerRef.current)
    }

    resizeTimerRef.current = setTimeout(() => {
      resizeTimerRef.current = null

      const fitAddon = fitAddonRef.current
      const terminal = terminalRef.current
      if (!fitAddon || !terminal || !mountedRef.current) return

      try {
        fitAddon.fit()
        const { cols, rows } = terminal
        window.api.terminal.resize(nodeId, cols, rows).catch((err: unknown) => {
          console.warn('[TerminalPanel] Resize IPC failed:', err)
        })
      } catch {
        // fit() can throw if container has zero dimensions
      }
    }, RESIZE_DEBOUNCE_MS)
  }, [nodeId])

  // -------------------------------------------------------------------------
  // Main effect: terminal lifecycle
  // -------------------------------------------------------------------------
  useEffect(() => {
    mountedRef.current = true
    const container = containerRef.current
    if (!container) return

    // --- Build theme with optional accent color override ---
    const theme = accentColor
      ? { ...terminalTheme, cursor: accentColor, selectionBackground: `${accentColor}4D` }
      : terminalTheme

    // --- Check for reduced motion preference (accessibility) ---
    const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches

    // --- Create Terminal instance ---
    const terminal = new Terminal({
      scrollback: 1000,
      fontSize: 13,
      fontFamily: "'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace",
      cursorBlink: !prefersReducedMotion,
      theme,
      allowProposedApi: true,
      screenReaderMode: prefersReducedMotion,
    })

    const fitAddon = new FitAddon()
    terminal.loadAddon(fitAddon)

    terminalRef.current = terminal
    fitAddonRef.current = fitAddon

    // --- Open terminal into container ---
    terminal.open(container)

    // --- Cleanup accumulator ---
    const cleanups: Array<() => void> = []

    // --- Keyboard handler: Ctrl+` escapes terminal focus ---
    const customKeyHandler = (event: KeyboardEvent): boolean => {
      if (event.ctrlKey && (event.key === '`' || event.key === '~')) {
        event.preventDefault()
        terminal.blur()
        // Return focus to the parent canvas / artboard
        const artboardParent = container.closest('[data-artboard]') as HTMLElement | null
        if (artboardParent) {
          artboardParent.focus()
        } else {
          // Fallback: blur to document
          ;(document.activeElement as HTMLElement | null)?.blur()
        }
        return false
      }
      return true
    }
    terminal.attachCustomKeyEventHandler(customKeyHandler)

    // --- Async initialization ---
    const init = async (): Promise<void> => {
      if (!mountedRef.current) return

      try {
        // 1. Spawn terminal (main process will no-op if session already exists for nodeId)
        await window.api.terminal.spawn({
          nodeId,
          sessionId,
          cols: terminal.cols,
          rows: terminal.rows,
        })
      } catch (err) {
        if (!mountedRef.current) return
        terminal.writeln(`\x1b[31m[Error] Failed to spawn terminal: ${err instanceof Error ? err.message : String(err)}\x1b[0m`)
        return
      }

      if (!mountedRef.current) return

      // 2. Replay scrollback
      try {
        const scrollback = await window.api.terminal.getScrollback(nodeId)
        if (mountedRef.current && scrollback.length > 0) {
          for (const line of scrollback) {
            terminal.writeln(line)
          }
        }
      } catch (err) {
        console.warn('[TerminalPanel] Scrollback replay failed:', err)
      }

      if (!mountedRef.current) return

      // 3. Initial fit
      try {
        fitAddon.fit()
        await window.api.terminal.resize(nodeId, terminal.cols, terminal.rows)
      } catch {
        // Non-critical — terminal will work at default size
      }

      if (!mountedRef.current) return

      // 4. Wire user input -> PTY
      const inputDisposable = terminal.onData((data: string) => {
        window.api.terminal.write(nodeId, data).catch((err: unknown) => {
          console.warn('[TerminalPanel] Write IPC failed:', err)
        })
      })
      cleanups.push(() => inputDisposable.dispose())

      // 5. Wire PTY output -> xterm.js
      const removeDataListener = window.api.terminal.onData(nodeId, (data: string) => {
        if (mountedRef.current && terminalRef.current) {
          terminalRef.current.write(data)
        }
      })
      cleanups.push(removeDataListener)

      // 6. Wire PTY exit -> terminal message
      const removeExitListener = window.api.terminal.onExit(nodeId, (exitCode: number) => {
        if (mountedRef.current && terminalRef.current) {
          terminalRef.current.writeln('')
          terminalRef.current.writeln(
            `\x1b[33m[Process exited with code ${exitCode}]\x1b[0m`
          )
        }
      })
      cleanups.push(removeExitListener)
    }

    init().catch((err: unknown) => {
      console.error('[TerminalPanel] Init failed:', err)
    })

    // --- ResizeObserver for container dimension changes ---
    const resizeObserver = new ResizeObserver(() => {
      handleResize()
    })
    resizeObserver.observe(container)
    cleanups.push(() => resizeObserver.disconnect())

    // --- Cleanup on unmount ---
    return () => {
      mountedRef.current = false

      // Clear any pending resize timer
      if (resizeTimerRef.current !== null) {
        clearTimeout(resizeTimerRef.current)
        resizeTimerRef.current = null
      }

      // Run all accumulated cleanups
      for (const cleanup of cleanups) {
        try {
          cleanup()
        } catch {
          // Ignore cleanup errors
        }
      }

      // Dispose xterm.js instances
      try {
        fitAddon.dispose()
      } catch {
        // Already disposed
      }
      try {
        terminal.dispose()
      } catch {
        // Already disposed
      }

      terminalRef.current = null
      fitAddonRef.current = null
    }
  }, [nodeId, sessionId, accentColor, handleResize])

  return (
    <div
      ref={containerRef}
      className={`terminal-panel ${className ?? ''}`}
      aria-label={`Terminal for node ${nodeId}`}
      style={{
        width: '100%',
        height: '100%',
        minHeight: 120,
        position: 'relative',
        overflow: 'hidden',
      }}
    >
      {/* Focus escape tooltip */}
      <div
        style={{
          position: 'absolute',
          bottom: 4,
          right: 8,
          fontSize: 11,
          color: 'rgba(224, 224, 224, 0.4)',
          pointerEvents: 'none',
          zIndex: 1,
          fontFamily: "'JetBrains Mono', 'Fira Code', monospace",
          userSelect: 'none',
        }}
      >
        Ctrl+` to return to canvas
      </div>
    </div>
  )
}

export const TerminalPanel = memo(TerminalPanelInner)
TerminalPanel.displayName = 'TerminalPanel'
